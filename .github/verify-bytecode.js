'use strict'

const fs = require('fs/promises')

const { ethers } = require('ethers')
const chalk = require('chalk')

const greenCheck = chalk.green('✓')
const redCross = chalk.red('×')

;(async function main() {
  const args = process.argv.slice(2)
  if (args.length === 0) {
    console.error('path to json file is required')
    process.exit(1)
  }
  const registryPath = args[0]
  const registry = JSON.parse(await fs.readFile(registryPath))
  const rpcUrl = process.env.RPC_URL
  if (!rpcUrl) {
    console.error('RPC_URL env variable is missing')
    process.exit(1)
  }
  const provider = new ethers.providers.StaticJsonRpcProvider(rpcUrl)
  const promises = registry.map(async (desc) => {
    const isMatched = await verifyBytecode(desc, provider)
    return {
      isMatched,
      desc
    }
  })
  const results = (await Promise.allSettled(promises)).sort((a, b) => -a.value?.isMatched + b.value?.isMatched)
  for (const result of results.filter((e) => e.status === 'fulfilled')) {
    let msg = result.value.isMatched ? greenCheck : redCross
    msg += ` ${result.value.desc.name}${chalk.grey('@')}${chalk.blue(result.value.desc.address)}`
    console.log(result.value.isMatched ? msg : chalk.red(msg))
  }
  const failures = results.filter((e) => e.status === 'rejected')
  for (const fail of failures) {
    console.log(chalk.red(fail.reason))
  }
  if (failures.length || results.filter((e) => e.value?.isMatched === false)) {
    process.exit(1)
  }
})()

/**
 * @param {Object} desc
 * @param {string} desc.address
 * @param {string} desc.txHash
 * @param {string} desc.artifactPath
 * @param {ethers.providers.Provider} provider
 * @returns {Promise<boolean>}
 */
async function verifyBytecode(desc, provider) {
  const artifact = JSON.parse(await fs.readFile(desc.artifactPath))
  const deployedBytecode = await provider.getCode(desc.address)
  const compiledBytecode = artifact.deployedBytecode
  const language = artifact.language ?? 'solidity'

  if (!compiledBytecode || compiledBytecode.length <= 2) {
    throw new Error(`null bytecode read from artifact ${desc.artifactPath}`)
  }

  const status = compareDeployedBytecode(deployedBytecode, compiledBytecode, language)
  if (status === undefined) {
    const tx = await provider.getTransaction(desc.txHash)
    if (tx.creates !== desc.address) {
      throw new Error(`wrong deploy transaction for ${desc.address}`)
    }
    if (!tx.data) {
      throw Error(`no creation bytecode at tx ${desc.txHash}`)
    }
    return compareCreationBytecode(tx.data, artifact.bytecode, language)
  }
  return status
}

/**
 * @param {string} blockchainBytecode
 * @param {string} artifactBytecode
 * @param {string} language
 * @returns {(boolean|undefined)}
 */
function compareDeployedBytecode(blockchainBytecode, artifactBytecode, language) {
  if (language === 'solidity') {
    artifactBytecode = replaceSolidityLinks(artifactBytecode, blockchainBytecode)
  }

  if (blockchainBytecode === artifactBytecode) {
    return true
  }

  if (language === 'solidity') {
    const trimmedDeployed = trimSolidityMeta(blockchainBytecode)
    const trimmedCompiled = trimSolidityMeta(artifactBytecode)

    if (trimmedDeployed.length !== trimmedCompiled.length) {
      return false
    }

    if (trimmedDeployed === trimmedCompiled) {
      return true
    }
  }

  return undefined
}

/**
 * @param {string} blockchainBytecode
 * @param {string} artifactBytecode
 * @param {string} language
 * @returns {boolean}
 */
function compareCreationBytecode(blockchainBytecode, artifactBytecode, language) {
  let compiledBytecode = artifactBytecode
  if (language === 'solidity') {
    compiledBytecode = trimSolidityMeta(compiledBytecode)
  }

  // The reason why this uses `startsWith` instead of `===` is that
  // creationData may contain constructor arguments at the end part.
  if (blockchainBytecode.startsWith(compiledBytecode)) {
    return true
  }

  return false
}

/**
 * Remove metadata from bytecode generated by solidity
 * @see https://docs.soliditylang.org/en/v0.8.15/metadata.html
 * @param {string} bytecode
 * @returns {string}
 */
function trimSolidityMeta(bytecode) {
  // Last 4 chars of bytecode specify byte size of metadata component.
  const metaSize = parseInt(bytecode.slice(-4), 16) * 2 + 4
  // When the length of metadata is not appended at the end, it will likely overshoot.
  // There's no metadata to trim.
  if (metaSize > bytecode.length) {
    return bytecode
  }

  return bytecode.slice(0, bytecode.length - metaSize)
}

/**
 * Replace solidity libraries links by the actual values retrieved from blockchain
 * @see https://docs.soliditylang.org/en/latest/contracts.html#libraries
 * @param {string} compiledBytecode
 * @param {string} deployedBytecode
 * @returns {string}
 */
function replaceSolidityLinks(compiledBytecode, deployedBytecode) {
  const PLACEHOLDER_START = '__$'
  const PLACEHOLDER_LENGTH = 40

  let index = compiledBytecode.indexOf(PLACEHOLDER_START)
  for (; index !== -1; index = compiledBytecode.indexOf(PLACEHOLDER_START)) {
    const placeholder = compiledBytecode.slice(index, index + PLACEHOLDER_LENGTH)
    const address = deployedBytecode.slice(index, index + PLACEHOLDER_LENGTH)
    const regexCompatiblePlaceholder = placeholder.replace('__$', '__\\$').replace('$__', '\\$__')
    const regex = RegExp(regexCompatiblePlaceholder, 'g')
    compiledBytecode = compiledBytecode.replace(regex, address)
  }

  return compiledBytecode
}
